\section{Partial derivatives}

The syntax of patterns and regular expressions, as well as the formal
specification of the pattern matching relation can now be used to define the
pattern partial derivative function.

\subsection{Sets of expression sets}

\cite{pd-ere} describes a way to break the derivative of a regular expression
into a union of derivated terms. This union is equivalent to the choice
operator $+$ on the resulting terms. The article defines a representation of a
partial derivative as a set of expression sets in which the expression sets
represent the intersection of terms, and the sets of expression sets represent
their union.

\begin{tabular}{lll}
   $\eset$	& $::=$ & $\{r_1, r_2, \dots, r_n\}$ \\
   $\esets$	& $::=$ & $\{\eset_1, \eset_2, \dots, \eset_n\}$ \\
\end{tabular}

It can be recognised that representation of regular expressions is essentially
a disjunctive normal form (DNF) of atomic regular expressions.


\subsubsection{Sets of pattern sets}

The partial derivative operations are defined on extended regular expressions
and result in sets of expression sets. Pattern partial derivatives as defined
in \cite{pd-pat} result in a list of pairs containing the derivated term as
well as a transition function $x \mapsto l$ recording the fact that the letter
$l$ has been consumed by a pattern under a variable $x$. This function must be
recorded in the set of pattern sets, as well. Since the equivalent of a
derivated term is the expression set $\eset$, we define the set of
pattern sets as: $\{ (\{ p \}, x \to l) \}$, the set of pairs containing
an expression set and the associated transition function.

\begin{tabular}{lll}
   $\pset$	& $::=$ & $(\{r_1, r_2, \dots, r_n\}, x \to l)$ \\
   $\psets$	& $::=$ & $\{\pset_1, \pset_2, \dots, \pset_n\}$ \\
\end{tabular}


\subsubsection{Conversions}

We can define translations from the above extended regular expression syntax
to the sets of sets representation. Let $\esets$ be a set of expression
sets, $\eset$ an expression set, and $r$ an expression, then we can
define the following operators:

Expression set from regular expression: $\cdot\esetOfRe :: r \to \eset$

\begin{tabular}{lll}
   $(r_1 \cap r_2)\esetOfRe$	& $=$	& $r_1\esetOfRe \cup r_2\esetOfRe$	\\
   $r\esetOfRe$			& $=$	& $\{r\}$				\\
\end{tabular}

Set of expression sets from regular expression: $\cdot\esetsOfRe :: r \to \esets$

\begin{tabular}{lll}
   $(r_1 + r_2)\esetsOfRe$	& $=$	& $r_1\esetsOfRe \cup r_2\esetsOfRe$	\\
   $r\esetsOfRe$		& $=$	& $\{r\esetOfRe\}$			\\
\end{tabular}

The following example shows how a regular expression is transformed into the
DNF representation of atomic expressions.

\begin{eg}
   $((aa \cap a^*) + b)\esetsOfRe$

   \begin{tabular}{lll}
      $((aa \cap a^*) + b)\esetsOfRe$
      & $=$	& $((aa \cap a^*)\esetsOfRe) \cup (b\esetsOfRe)$		\\
      & $=$	& $\{(aa \cap a^*)\esetOfRe\} \cup \{b\esetsOfRe\}$		\\
      & $=$	& $\{(aa)\esetOfRe \cup (a^*)\esetOfRe\} \cup \{\{b\}\}$	\\
      & $=$	& $\{\{aa\} \cup \{a^*\}\} \cup \{\{b\}\}$			\\
      & $=$	& $\{\{aa, a^*\}, \{b\}\}$					\\
   \end{tabular}
\end{eg}

If the operator at the highest level of the syntax tree is not the choice
operator $+$, the resulting set will contain exactly one expression set. If
the expression contains no intersections, the expression set will contain
exactly one atomic expression. A negation at the highest level is an example
of such a case:
$\neg((aa \cap a^*) + b)\esetsOfRe = \{\{\neg((aa \cap a^*) + b)\}\}$

The inverse operation, translating a set of expression sets back to a regular
expression, can be defined analogously.

Regular expression from expression set: $\cdot\reOfEset :: \eset \to r$

\begin{tabular}{lll}
   $\{r\}\reOfEset$			& $=$	& $r$				\\
   $(\{r\} \cup \eset)\reOfEset$	& $=$	& $r \cap \eset\reOfEset$	\\
\end{tabular}

Regular expression from a set of expression sets: $\cdot\reOfEsets :: \esets \to r$

\begin{tabular}{lll}
   $\{\eset\}\reOfEsets$		& $=$	& $\eset\reOfEset$		\\
   $(\{\eset\} \cup \esets)\reOfEsets$	& $=$	& $r + \esets\reOfEsets$	\\
\end{tabular}

The operation is not defined on empty sets, thus the set of expression sets
representing the empty language expression must be the set containing the set
with the empty language symbol: $\{\{\phi\}\}$.

The operators $\esetOfRe$ and $\reOfEset$ can be defined analogously for
patterns to construct pattern sets and reconstruct the pattern from them.
However, it should be noted that in order to break a pattern or expression
into a set of pattern or expression sets, the highest level operator must be
choice or intersection. In particular, a pattern group $(x:p)$ at the highest
level of the syntax tree makes it impossible to break a pattern into pieces.

TODO: can patterns/expressions inside a variable base/group be split, anyway?

We do not define $\esetsOfRe$ and $\reOfEsets$ for sets of pattern sets, and
there is no need for them, but the final pattern derivative as set of patterns
with transition functions can be obtained from a pattern using the function
$\mathit{patDeriv}$.

\[\mathit{patDeriv}(p, l)
   = \{ (\pset\reOfEset, f) | (\pset, f) \in \dd{l}(p) \}\]


\subsubsection{Operators on sets of pattern sets}

Caron et al. define several operators on sets of expression sets and use them
to define the partial derivative of an extended regular expression. We define
these operators in the syntax used in \cite{pd-pat}.

\begin{tabular}{lll}
   $\esets \circledcdot r_2$
      & $=$
      & $\{ \{ (r_1, r_2) | r_1 \in \eset \} | \eset \in \esets \}$
      \\

   $\esets_1 \circledcap \esets_2$
      & $=$
      & $\{
           \eset_1 \cup \eset_2
           | \eset_1 \in \esets_1, \eset_2 \in \esets_2
        \}$
      \\

   $\circledneg\esets$
      & $=$
      & $\{ \{ \neg r | r \in \eset \} | \eset \in \esets \}$
      \\
\end{tabular}

We can recognise that these operators are essentially distributive laws
defined on sets of expression sets. E.g. the $\circledcdot$ operator
concatenates an expression to every expression in every set in the expression
set $\esets$, the $\circledneg$ operator negates every expression in the
set.

The expression set operators must be defined for pattern derivatives, but
since pattern derivatives carry a transition function $f$, these must be
sensibly combined in the set operators.

\begin{tabular}{lll}
   $\psets \circledcdot_{mod} p_2$
      & $=$
      & $\{ (\{ (p_1, p_2) | p_1 \in \eset \}, f \circ mod) | (\eset, f) \in \psets \}$
      \\

   $\psets_1 \circledcap \psets_2$
      & $=$
      & $\{
           (\eset_1 \cup \eset_2, f_1 \circ f_2)
           | (\eset_1, f_1) \in \psets_1, (\eset_2, f_2) \in \psets_2
        \}$
      \\
\end{tabular}

In $\circledcdot$, the $mod$ function can modify the environment before
passing it to the transition function.  The operator $\circledneg$ is not
defined for sets of pattern sets, since there is no negation for patterns.


\subsection{Pattern partial derivatives}

In definition 2 of \cite{pd-ere}, the partial derivative of a regular
expression $\dda(r)$ is defined. We repeat the definition here, with one
modification, and with the addition of expression repetition.

\begin{minipage}[t]{0.4\textwidth}
   \[\textbf{(1)} \dda(\phi) = \dda(\varepsilon) = \dda(b) = \{\{ \phi \}\}\]
\end{minipage}
\begin{minipage}[t]{0.4\textwidth}
   \[\textbf{(2)} \dda(a) = \{\{ \varepsilon \}\}\]
\end{minipage}

\begin{minipage}[t]{0.4\textwidth}
   \[\textbf{(3)} \dda(r_1 + r_2) = \dda(r_1) \cup \dda(r_2)\]
\end{minipage}
\begin{minipage}[t]{0.4\textwidth}
   \[\textbf{(4)} \dda(r^*) = \dda(r) \circledcdot r^*\]
\end{minipage}

\begin{minipage}[t]{0.6\textwidth}
\[\textbf{(5)} \dda((r_1, r_2)) =
    \begin{cases}
       \dda(r_1) \circledcdot r_2 & \text{if } \varepsilon \not\in L(r_1\esetsOfRe) \\
       \dda(r_1) \circledcdot r_2 \cup \dda(r_2) & \text{otherwise}
    \end{cases}
\]
\end{minipage}
\begin{minipage}[t]{0.3\textwidth}
   \[\textbf{(6)} \dda(r_1 \cap r_2) = \dda(r_1) \circledcap \dda(r_2)\]
\end{minipage}

\begin{minipage}[t]{0.4\textwidth}
   \[\textbf{(7)} \dda(r^n) =
       \begin{cases}
          \dda(r) & \text{if } n = 1 \\
          \dda((r, r^{n-1})) & \text{otherwise}
       \end{cases}
   \]
\end{minipage}
\begin{minipage}[t]{0.4\textwidth}
   \[\textbf{(8)} \dda(\neg r) = \circledneg (\dda(r))\]
\end{minipage}

Caron et al. define \textbf{(1)} as $\dda(b) = \emptyset$, but this yields
incorrect results when combined with negation. Consider for example the
regular expression $\neg b$, which matches anything that is not a `b', such as
``a''.  The partial derivative over `a' according to \cite{pd-ere} would be
constructed as follows:

\[\dda(\neg b)
   =_{\textbf{(8)}} \circledneg \dda(b)
   =_{\textbf{(1)}} \circledneg (\emptyset)
   = \emptyset
\]

The correct partial derivative is $\dda(\neg b) = \{\{\Sigma^*\}\}$. With our
definition, we construct the partial derivative as follows, considering that
the negation of the empty language is every possible word made from any number
of letters in the alphabet $\Sigma$:

\[\dda(\neg b)
   =_{\textbf{(8)}} \circledneg \dda(b)
   =_{\textbf{(1)}} \circledneg (\{\{\phi\}\})
   = \{\{\neg\phi\}\}
   = \{\{\Sigma^*\}\}
\]

We define the partial derivative of an extended pattern expression using the
operators $\circledcdot$ and $\circledcap$, omitting negation.

\[\textbf{(1)} \dda(x:r)
   = \{ (\{ \eset\reOfEset \}, update(x,a)) | \eset \in \dda(r) \},\]
\[\textbf{(2)} \dda(x:p)
   = \{ (\{ (x:\pset\reOfEset) \}, update(x,a) \circ f) | (\pset, f) \in \dda(p) \},\]
\[\textbf{(3)} \dda(p_1 + p_2) = \dda(p_1) \cup \dda(p_2),\]
\[\textbf{(4)} \dda(p^*) = \dda(p) \circledcdot_{\iterate} p^*,\]
\[\textbf{(5)} \dda((p_1, p_2)) =
    \begin{cases}
       \dda(r_1) \circledcdot_{id} p_2 & \text{if } \varepsilon \not\in L(p_1\reOfEsets) \\
       \dda(r_1) \circledcdot_{id} p_2 \cup \dda(p_2) & \text{otherwise}
    \end{cases}
\]
\[\textbf{(6)} \dda(p_1 \cap p_2) = \dda(p_1) \circledcap \dda(p_2)\]
\[\textbf{(7)} \dda(p^n) =
    \begin{cases}
       \{ (\pset, f \circ \iterate) | (\pset, f) \in \dda(p) \} & \text{if } n = 1 \\
       \dda(p) \circledcdot_{\iterate} p^{n-1} & \text{otherwise}
    \end{cases}
\]

In \textbf{(5)}, the identity function is given as modifier to the
$\circledcdot$ operator, keeping the environment as is before passing it to
the transition function. The $\iterate$ function can modify the environment
for the two iterating patterns $p^*$ and $p^n$. It can choose to keep only the
last match or all matches, by renaming past recorded match variables. This
function is described in more detail in section 5.1 of \cite{pd-pat}. The
$\fv(p)$ function finds all free variables used in the pattern, and is defined
in section 3.1 of the same paper.


% vim:tw=78
