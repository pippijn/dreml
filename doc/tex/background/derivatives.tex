\section{Derivatives of regular expression}

Janusz Brzozowski introduces a method of symbolically computing the left
derivative of a regular expression over an input symbol $l$. After constructing
a deterministic finite automaton for the language, one can follow the transition
on $l$ and take the target state as the start state of a new, derived automaton.
The language this automaton accepts is the same as the language accepted by an
automaton constructed from a Brzozowski derivative over $l$.

Constructing a DFA from a regular expression by the method described in
\cite{thompson} generally goes via an epsilon NFA by computing an epsilon
closure and then performing a subset construction of NFA states into DFA states.
On the contrary, Brzozowski's derivative method directly results in a DFA.

The derivative operation is defined on basic regular expressions $r$ with an
input alphabet $\Sigma$.

\begin{defn}
   \label{defn-bre}
   Basic regular expression syntax.

   \begin{tabular}{lrll}
      $r$	& $::=$	& $r+r$				& Choice		\\
		& $|$	& $(r,r)$			& Concatenation		\\
		& $|$	& $r^*$				& Kleene star		\\
		& $|$	& $\varepsilon$			& Empty word		\\
		& $|$	& $\phi$			& Empty language	\\
		& $|$	& $l \in Sigma$			& Letters		\\
   \end{tabular}
\end{defn}

On this syntax, Brzozowski defines the left derivative.

\begin{defn}
   \label{defn-deriv}
   Brzozowski's regular expression derivative

   \begin{tabular}{lrl}
      $\phi \setminus l$	& $=$	& $phi$	\\
      $\varepsilon \setminus l$	& $=$	& $phi$	\\
      $l_1 \setminus l_2$	& $=$	&
          $\begin{cases}
             \varepsilon & \text{if } l_1 = l_2 \\
             \phi & \text{otherwise}
          \end{cases}$	\\
      $(r_1 + r_2) \setminus l$	& $=$	& $r_1 \setminus l + r_2 \setminus l$	\\
      $(r_1 + r_2) \setminus l$	& $=$	&
          $\begin{cases}
             (r_1 \setminus l, r_2) & \text{if } \varepsilon \not\in L(r_1\esetsOfRe) \\
             (r_1 \setminus l, r_2) + r_2 \setminus l & \text{otherwise}
          \end{cases}$	\\
      $r^* \setminus l$		& $=$	& $(r \setminus l, r^*)$	\\
   \end{tabular}
\end{defn}

An automaton is produced by iterating over the set of input symbols (the
alphabet $\Sigma$) and producing a derivative for each symbol. The resulting
derivated terms are then subject to the same process. This is repeated until no
new derivatives appear. As the automaton produced is in fact a deterministic
finite automaton, the number of states produced by this method is exponential in
the expression length. This is problematic for certain expressions such as
\verb!(a?){n}(a){n}!. Although the runtime of a derivative automaton is linear
in the input length and has a small constant factor, the automaton construction
can become a lengthy operation.


% vim:tw=80
