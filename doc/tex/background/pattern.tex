\section{Pattern sub-matching}

Based on the ideas by Brzozowski and Antimirov, Martin Sulzmann and Kenny Zhuo
Ming Lu introduced the notion of regular expression sub-matching to partial
derivatives. In addition to solving the word problem, that is to determine
whether a regular expression matches the input, this advancement allows to
assign parts of the matched sequence to different variables. By inspecting the
resulting matching environment, one can extract the subsequences of interest.
This is particularly useful when dealing with programming languages or search
and replace functionality in editors.

\subsection{Syntax}

In \cite{pdpat}, Sulzmann and Lu define the abstract syntax for expression
patterns:

\begin{defn}
   \label{defn-pat}
   Syntax of regular expression patterns.

   \begin{tabular}{lrll}
      $p$	& $::=$	& $(x:r)$	& Variables Base	\\
		& $|$	& $(x:p)$	& Variables Group	\\
		& $|$	& $p+p$		& Choice		\\
		& $|$	& $(p,p)$	& Concatenation		\\
		& $|$	& $p^*$		& Kleene star		\\
   \end{tabular}
\end{defn}

A variables base contains a regular expression as defined above and does not
contain any more patterns, so that the derivative operation on this class of
patterns can be defined in terms of definition \ref{defn-deriv}. The definition
and precise description of pattern derivatives is not repeated here, but can be
found in \cite{pdpat}.

The definition of pattern partial derivatives is such that it yields a set of
derivated terms along with a transition or matching function. In the first step
of the implementation, the match was recorded in the pattern structure, itself,
building on the following syntax:

\begin{defn}
   \label{defn-pat-with-match}
   Syntax of regular expression patterns with match.

   \begin{tabular}{lrll}
      $p$	& $::=$	& $(x|w:r)$	& Variables Base  with match $m$	\\
		& $|$	& $(x|w:p)$	& Variables Group with match $m$	\\
		& $|$	& $\dots$	& The rest is the same as above.	\\
   \end{tabular}
\end{defn}

An important additional requirement to the partial derivatives is that the
operation should no longer yield an unordered set, but a set ordered by the
appearance of their origins in the expression operand. Thus, the partial
derivative of $(x:(a,c))(y:(a,b))$ over the input symbol $a$ must yield
$[(x:c),(y:b)]$ in that order. An unordered set is allowed within expressions
not containing pattern variables, so that $(a,c)(a,b) \setminus_p a$ may yield
$\{(b),(c)\}$.

\subsection{Sub-match extraction}

Programming languages usually contain a finite set of keywords and lexical rules
for different kinds of tokens. OCaml, for instance, specifies that an sequence
of Latin letters, starting with a capital letter, is a module name or a type
constructor name. A sequence starting with a minuscule is a type or variable
name, unless it is also a keyword. More complex rules exist for string literals,
character literals and type variables. OCaml comments can be nested, and
therefore not be matched by a regular expression.

When building a compiler for a programming language, one of the first steps
consists in tokenising or lexing the input. Considering a language containing
the keywords \verb!let! and \verb!in!, and the operators \verb!=! and \verb!+!,
we can create a regular expression
%
\[((l,e),t) + (i,n) + \verb'=' + \verb'+'\]
%
which matches a single lexical element of the language. However, without
sub-matching, we can not know which of the elements it actually is. In
\cite{pdpat}, Sulzmann and Lu describe an efficient method for constructing a
tagged NFA that can answer this question.

With sub-matching, we can write the above expression as the pattern
%
\[(x_\text{let}:((l,e),t)) + (x_\text{in}:(i,n)) + (x_\text{eq}:\verb'=') +
(x_\text{plus}:\verb'+')\]
%
The sub-matching automaton will yield a matching environment in which exactly
one of the variables $x_i$ is defined, allowing us to decide what kind of token
was matched and extract the precise spelling of that token. The latter is useful
in the presence of multiple spellings, which exists in the C programming
language in the form of digraphs and trigraphs, as well as in most programming
languages in the form of identifiers.

The expression above does not yet account for such constructs, so for
demonstration purposes, we introduce the \textit{identifier} token. The regular
expression for identifiers in our small lambda language is \verb![a-z]+!,
allowing only lower case Latin letters for simplicity. The lexer pattern now
needs to be extended, resulting in
%
\[(x_\text{let}:((l,e),t)) + (x_\text{in}:(i,n)) + (x_\text{id}:(a+\dots+z)^n) +
\dots\]
%
This expression contains an ambiguity, because the sequence \verb!let! can be
bound to either $x_\text{let}$ or $x_\text{id}$. The solution to this ambiguity
lies in a concept called \textit{matching strategies}, also introduced to
partial derivatives by \cite{pdpat}.

\subsection{Matching strategies}

Matching strategies define the observable sub-matching semantics on the pattern
syntax. Sulzmann and Lu introduce two possible strategies: Greedy Left-Most and
POSIX matching. Greedy Left-Most is the way Perl and most other common matching
algorithms resolve ambiguities. It is conceptionally simple: the first matching
sub-expression, when reading the pattern from left to right, is selected and the
matched subsequence is assigned to its variable.
% This strategy comes naturally with partial derivatives and non-deterministic
% automata. TODO: Why?
POSIX matching requires the longest match to be recorded in the environment. For
our simple lambda language example, both strategies would yield the same result,
but for example the pattern $((x:A+AB),(y:BAA+AA))$ matching the input $ABAA$
would, for greedy left-most matching, result in the match $\{x:AB, y:AA\}$, but
for POSIX matching it would yield $\{x:A, y:BAA\}$.

Without a matching strategy, the environment would contain every possible match,
which can be exponentially many. A strategy ensures that the algorithm keeps its
linear time complexity in the input length.


% vim:tw=80
