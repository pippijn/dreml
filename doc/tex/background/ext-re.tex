\section{Partial derivatives of extended regular expressions}

Caron, Champarnaud and Mignot extend Antimirov's partial derivatives with
additional boolean operators. In their paper \cite{pdere}, they introduce
negation $\neg$ and intersection $\cap$ and define them, as well as the existing
union or choice operator $+$, in terms of operations yielding a disjunctive
normal form of derivated terms.

First, we define the abstract syntax of extended regular expressions.

\begin{defn}
   \label{defn-ere-syn}
   Syntax of extended regular expressions.

   \begin{tabular}{lrll}
      $r$	& $::=$	& $r+r$				& Choice		\\
		& $|$	& $(r,r)$			& Concatenation		\\
		& $|$	& $r_e \cap r_e$		& Intersection		\\
        	& $|$	& $\neg r_e$			& Negation		\\
        	& $|$	& $r_e^n$			& Repetition		\\
		& $|$	& $r^*$				& Kleene star		\\
		& $|$	& $\varepsilon$			& Empty word		\\
		& $|$	& $\phi$			& Empty language	\\
		& $|$	& $l \in Sigma$			& Letters		\\
   \end{tabular}
\end{defn}


\subsection{Sets of expression sets}

\cite{pdere} describes a way to break the derivative of a regular expression
into a union of derivated terms. This union is equivalent to the choice operator
$+$ on the resulting terms. The article defines a representation of a partial
derivative as a set of expression sets in which the expression sets represent
the intersection of terms, and the sets of expression sets represent their
union.

\begin{defn}
   \label{defn-esets}
   Syntax for sets of expression sets.

   \begin{tabular}{lll}
      $\eset$	& $::=$ & $\{r_1, r_2, \dots, r_n\}$ \\
      $\esets$	& $::=$ & $\{\eset_1, \eset_2, \dots, \eset_n\}$ \\
   \end{tabular}
\end{defn}

It can be recognised that representation of regular expressions is essentially a
disjunctive normal form (DNF) of atomic regular expressions.

\subsubsection{Operators on sets of expression sets}

Caron et al. define several operators on sets of expression sets and use them to
define the partial derivative of an extended regular expression. We define these
operators in the syntax used in \cite{pdpat}.

\begin{defn}
   \label{defn-eset-ops}
   Distributive laws on sets of expression sets.

   \begin{tabular}{lll}
      $\esets \circledcdot r_2$
         & $=$
         & $\{ \{ (r_1, r_2) | r_1 \in \eset \} | \eset \in \esets \}$
         \\

      $\esets_1 \circledcap \esets_2$
         & $=$
         & $\{
              \eset_1 \cup \eset_2
              | \eset_1 \in \esets_1, \eset_2 \in \esets_2
           \}$
         \\

      $\circledneg\esets$
         & $=$
         & $\{ \{ \neg r | r \in \eset \} | \eset \in \esets \}$
         \\
   \end{tabular}
\end{defn}

We can recognise that these operators are essentially distributive laws defined
on sets of expression sets. E.g. the $\circledcdot$ operator concatenates an
expression to every expression in every set in the expression set $\esets$, the
$\circledneg$ operator negates every expression in the set.

The following examples use the extended regular expression syntax as specified
in definition \ref{defn-syn}.

\begin{eg}
   $((a^* \cap aa) + ab)\esetsOfRe \circledcdot c^*$

   \begin{tabular}{lll}
      $=$ &
         $\{\{a^*, aa\}, \{ab\}\} \circledcdot c^*$
      \\ $=$ &
         $\{ \{ (r_1, c^*) | r_1 \in \eset \} | \eset \in \{\{a^*, aa\}, \{ab\}\} \}$
      \\ $=$ &
         $\{ \{ (r_1, c^*) | r_1 \in \{a^*, aa\} \}, \{ (r_1, c^*) | r_1 \in \{ab\} \} \}$
      \\ $=$ &
         $\{ \{ (a^*, c^*), (aa, c^*) \}, \{ (ab, c^*) \} \}$
   \end{tabular}

   The resulting set of expression sets can be converted back to a regular
   expression by the $\cdot\reOfEsets$ operator, yielding $(a^*c^* \cap aac^*) +
   abc^*$.
\end{eg}

\begin{eg}
   $((a^* \cap aa) + b^*)\esetsOfRe \circledcap (a^* + (b^* \cap bb))\esetsOfRe$

   \begin{tabular}{lll}
      $=$ &
         $\{\{a^*, aa\}, \{b^*\}\} \circledcap \{\{a^*\}, \{b^*, bb\}\}$
      \\ $=$ &
         $\{
            \eset_1 \cup \eset_2
            | \eset_1 \in \{\{a^*, aa\}, \{b^*\}\}
            , \eset_2 \in \{\{a^*\}, \{b^*, bb\}\}
         \}$
      \\ $=$ &
         $\{
            \{a^*, aa\} \cup \{a^*\},
            \{a^*, aa\} \cup \{b^*, bb\},
            \{b^*\} \cup \{a^*\},
            \{b^*\} \cup \{b^*, bb\}
          \}$
      \\ $=$ &
         $\{
            \{a^*, aa\},
            \{a^*, aa, b^*, bb\},
            \{b^*, a^*\},
            \{b^*, bb\}
          \}$
   \end{tabular}

   Applying operator $\reOfEsets$ on the result yields the regular expression
   $(a^* \cap aa) + (a^* \cap aa \cap b^* \cap bb) + (b^* \cap a^*) + (b^* \cap
   bb)$. In this case, we could simplify the expression, using the knowledge
   that $L(a^* \cap b^*) = \emptyset$, and obtain the final result $(a^* \cap
   aa) + (b^* \cap bb)$.
\end{eg}


\subsection{Expression partial derivative}

In definition 2 of \cite{pdere}, the partial derivative of a regular expression
$\dda(r)$ is specified. We repeat the definition here, with one modification,
and with the addition of expression repetition.

\needspace{7cm}
\begin{defn}
   \label{defn-pd-eset}
   Expression partial derivatives as sets of expression sets.

   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{1} \dda(\phi) = \dda(\varepsilon) = \dda(b) = \{\{ \phi \}\}\]
   \end{minipage}
   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{2} \dda(a) = \{\{ \varepsilon \}\}\]
   \end{minipage}

   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{3} \dda(r_1 + r_2) = \dda(r_1) \cup \dda(r_2)\]
   \end{minipage}
   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{4} \dda(r^*) = \dda(r) \circledcdot r^*\]
   \end{minipage}

   \begin{minipage}[t]{0.6\textwidth}
      \[\nr{5} \dda((r_1, r_2)) =
          \begin{cases}
             \dda(r_1) \circledcdot r_2 & \text{if } \varepsilon \not\in L(r_1\esetsOfRe) \\
             \dda(r_1) \circledcdot r_2 \cup \dda(r_2) & \text{otherwise}
          \end{cases}
      \]
   \end{minipage}
   \begin{minipage}[t]{0.3\textwidth}
      \[\nr{6} \dda(r_1 \cap r_2) = \dda(r_1) \circledcap \dda(r_2)\]
   \end{minipage}

   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{7} \dda(r^n) =
          \begin{cases}
             \dda(r) & \text{if } n = 1 \\
             \dda((r, r^{n-1})) & \text{otherwise}
          \end{cases}
      \]
   \end{minipage}
   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{8} \dda(\neg r) = \circledneg (\dda(r))\]
   \end{minipage}
\end{defn}

Caron et al. define \nr{1} as $\dda(b) = \emptyset$, but this yields incorrect
results when combined with negation. Consider for example the regular expression
$\neg b$, which matches anything that is not a `b', such as ``a''.  The partial
derivative over `a' according to \cite{pdere} would be constructed as follows:

\[\dda(\neg b)
   =_{\nr{8}} \circledneg \dda(b)
   =_{\nr{1}} \circledneg (\emptyset)
   = \emptyset
\]

The correct partial derivative is $\dda(\neg b) = \{\{\Sigma^*\}\}$. With our
definition, we construct the partial derivative as follows, considering that the
negation of the empty language is every possible word made from any number of
letters in the alphabet $\Sigma$:

\[\dda(\neg b)
   =_{\nr{8}} \circledneg \dda(b)
   =_{\nr{1}} \circledneg (\{\{\phi\}\})
   = \{\{\neg\phi\}\}
   = \{\{\Sigma^*\}\}
\]



% vim:tw=80
