\section{Partial derivatives of extended regular expressions}

Caron, Champarnaud and Mignot extend Antimirov's partial derivatives with
additional boolean operators. In their paper \cite{pdere}, they introduce
negation $\neg$ and intersection $\cap$ and define them, as well as the existing
union or choice operator $+$, in terms of operations yielding a disjunctive
normal form of derivated terms.

First, we define the abstract syntax of extended regular expressions.

\begin{defn}
   \label{defn-ere-syn}
   Syntax of extended regular expressions.

   \begin{tabular}{lrll}
      $r$	& $::=$	& $r+r$				& Choice		\\
		& $|$	& $(r,r)$			& Concatenation		\\
		& $|$	& $r_e \cap r_e$		& Intersection		\\
        	& $|$	& $\neg r_e$			& Negation		\\
        	& $|$	& $r_e^n$			& Repetition		\\
		& $|$	& $r^*$				& Kleene star		\\
		& $|$	& $\varepsilon$			& Empty word		\\
		& $|$	& $\phi$			& Empty language	\\
		& $|$	& $l \in Sigma$			& Letters		\\
   \end{tabular}
\end{defn}


\subsection{Sets of expression sets}

\cite{pdere} describes a way to break the derivative of a regular expression
into a union of derivated terms. This union is equivalent to the choice operator
$+$ on the resulting terms. The article defines a representation of a partial
derivative as a set of expression sets in which the expression sets represent
the intersection of terms, and the sets of expression sets represent their
union.

\begin{defn}
   \label{defn-esets}
   Syntax for sets of expression sets.

   \begin{tabular}{lll}
      $\eset$	& $::=$ & $\{r_1, r_2, \dots, r_n\}$ \\
      $\esets$	& $::=$ & $\{\eset_1, \eset_2, \dots, \eset_n\}$ \\
   \end{tabular}
\end{defn}

It can be recognised that representation of regular expressions is essentially a
disjunctive normal form (DNF) of atomic regular expressions.

\subsubsection{Conversions}

We can define translations from the above extended regular expression syntax to
the sets of sets representation. Let $\esets$ be a set of expression sets,
$\eset$ an expression set, and $r$ an expression, then we can define the
following operators:

\begin{defn}
   \label{defn-re2esets}
   Conversions from regular expressions to expression sets.

   Expression set from regular expression:
   $\cdot\esetOfRe :: r \to \eset$

   \begin{tabular}{lll}
      $(r_1 \cap r_2)\esetOfRe$	& $=$	& $r_1\esetOfRe \cup r_2\esetOfRe$	\\
      $r\esetOfRe$			& $=$	& $\{r\}$			\\
   \end{tabular}

   Set of expression sets from regular expression:
   $\cdot\esetsOfRe :: r \to \esets$

   \begin{tabular}{lll}
      $(r_1 + r_2)\esetsOfRe$	& $=$	& $r_1\esetsOfRe \cup r_2\esetsOfRe$	\\
      $r\esetsOfRe$		& $=$	& $\{r\esetOfRe\}$			\\
   \end{tabular}
\end{defn}

The following example shows how a regular expression is transformed into the DNF
representation of atomic expressions.

\begin{eg}
   $((aa \cap a^*) + b)\esetsOfRe$

   \begin{tabular}{lll}
      $((aa \cap a^*) + b)\esetsOfRe$
      & $=$	& $((aa \cap a^*)\esetsOfRe) \cup (b\esetsOfRe)$		\\
      & $=$	& $\{(aa \cap a^*)\esetOfRe\} \cup \{b\esetsOfRe\}$		\\
      & $=$	& $\{(aa)\esetOfRe \cup (a^*)\esetOfRe\} \cup \{\{b\}\}$	\\
      & $=$	& $\{\{aa\} \cup \{a^*\}\} \cup \{\{b\}\}$			\\
      & $=$	& $\{\{aa, a^*\}, \{b\}\}$					\\
   \end{tabular}
\end{eg}

If the operator at the highest level of the syntax tree is not the choice
operator $+$, the resulting set will contain exactly one expression set. If the
expression contains no intersections, the expression set will contain exactly
one atomic expression. A negation at the highest level is an example of such a
case: $\neg((aa \cap a^*) + b)\esetsOfRe = \{\{\neg((aa \cap a^*) + b)\}\}$

The inverse operation, translating a set of expression sets back to a regular
expression, can be defined analogously.

\begin{defn}
   \label{defn-esets2re}
   Conversions from expression sets back to regular expressions.

   Regular expression from expression set: $\cdot\reOfEset :: \eset \to r$

   \begin{tabular}{lll}
      $\{r\}\reOfEset$			& $=$	& $r$				\\
      $(\{r\} \cup \eset)\reOfEset$	& $=$	& $r \cap \eset\reOfEset$	\\
   \end{tabular}

   Regular expression from a set of expression sets: $\cdot\reOfEsets :: \esets \to r$

   \begin{tabular}{lll}
      $\{\eset\}\reOfEsets$		& $=$	& $\eset\reOfEset$		\\
      $(\{\eset\} \cup \esets)\reOfEsets$	& $=$	& $r + \esets\reOfEsets$	\\
   \end{tabular}
\end{defn}

The operation is not defined on empty sets, thus the set of expression sets
representing the empty language expression must be the set containing the set
with the empty language symbol: $\{\{\phi\}\}$.

\subsubsection{Operators on sets of expression sets}

Caron et al. define several operators on sets of expression sets and use them to
define the partial derivative of an extended regular expression\cite{pdere}. We
define these operators in the syntax used in \cite{pdpat}.

\begin{defn}
   \label{defn-eset-ops}
   Distributive laws on sets of expression sets.

   \begin{tabular}{lll}
      $\esets \circledcdot r_2$
         & $=$
         & $\{ \{ (r_1, r_2) | r_1 \in \eset \} | \eset \in \esets \}$
         \\

      $\esets_1 \circledcap \esets_2$
         & $=$
         & $\{
              \eset_1 \cup \eset_2
              | \eset_1 \in \esets_1, \eset_2 \in \esets_2
           \}$
         \\

      $\circledneg\esets$
         & $=$
         & $\{ \{ \neg r | r \in \eset \} | \eset \in \esets \}$
         \\
   \end{tabular}
\end{defn}

We can recognise that these operators are essentially distributive laws defined
on sets of expression sets. E.g. the $\circledcdot$ operator concatenates an
expression to every expression in every set in the expression set $\esets$, the
$\circledneg$ operator negates every expression in the set.

The following examples use the extended regular expression syntax as specified
in definition \ref{defn-syn}.

\begin{eg}
   $((a^* \cap aa) + ab)\esetsOfRe \circledcdot c^*$

   \begin{tabular}{lll}
      $=$ &
         $\{\{a^*, aa\}, \{ab\}\} \circledcdot c^*$
      \\ $=$ &
         $\{ \{ (r_1, c^*) | r_1 \in \eset \} | \eset \in \{\{a^*, aa\}, \{ab\}\} \}$
      \\ $=$ &
         $\{ \{ (r_1, c^*) | r_1 \in \{a^*, aa\} \}, \{ (r_1, c^*) | r_1 \in \{ab\} \} \}$
      \\ $=$ &
         $\{ \{ (a^*, c^*), (aa, c^*) \}, \{ (ab, c^*) \} \}$
   \end{tabular}

   The resulting set of expression sets can be converted back to a regular
   expression by the $\cdot\reOfEsets$ operator, yielding $(a^*c^* \cap aac^*) +
   abc^*$.
\end{eg}

\begin{eg}
   $((a^* \cap aa) + b^*)\esetsOfRe \circledcap (a^* + (b^* \cap bb))\esetsOfRe$

   \begin{tabular}{lll}
      $=$ &
         $\{\{a^*, aa\}, \{b^*\}\} \circledcap \{\{a^*\}, \{b^*, bb\}\}$
      \\ $=$ &
         $\{
            \eset_1 \cup \eset_2
            | \eset_1 \in \{\{a^*, aa\}, \{b^*\}\}
            , \eset_2 \in \{\{a^*\}, \{b^*, bb\}\}
         \}$
      \\ $=$ &
         $\{
            \{a^*, aa\} \cup \{a^*\},
            \{a^*, aa\} \cup \{b^*, bb\},
            \{b^*\} \cup \{a^*\},
            \{b^*\} \cup \{b^*, bb\}
          \}$
      \\ $=$ &
         $\{
            \{a^*, aa\},
            \{a^*, aa, b^*, bb\},
            \{b^*, a^*\},
            \{b^*, bb\}
          \}$
   \end{tabular}

   Applying operator $\reOfEsets$ on the result yields the regular expression
   $(a^* \cap aa) + (a^* \cap aa \cap b^* \cap bb) + (b^* \cap a^*) + (b^* \cap
   bb)$. In this case, we could simplify the expression, using the knowledge
   that $L(a^* \cap b^*) = \emptyset$, and obtain the final result $(a^* \cap
   aa) + (b^* \cap bb)$.
\end{eg}


\subsection{Expression partial derivative}

In definition 2 of \cite{pdere}, the partial derivative of a regular expression
$\dda(r)$ is specified. We repeat the definition here, with one modification,
and with the addition of expression repetition.

\begin{defn}
   \label{defn-pd-eset}
   Expression partial derivatives as sets of expression sets.

   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{1} \dda(\phi) = \dda(\varepsilon) = \dda(b) = \{\{ \phi \}\}\]
   \end{minipage}
   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{2} \dda(a) = \{\{ \varepsilon \}\}\]
   \end{minipage}

   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{3} \dda(r_1 + r_2) = \dda(r_1) \cup \dda(r_2)\]
   \end{minipage}
   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{4} \dda(r^*) = \dda(r) \circledcdot r^*\]
   \end{minipage}

   \begin{minipage}[t]{0.6\textwidth}
      \[\nr{5} \dda((r_1, r_2)) =
          \begin{cases}
             \dda(r_1) \circledcdot r_2 & \text{if } \varepsilon \not\in L(r_1\esetsOfRe) \\
             \dda(r_1) \circledcdot r_2 \cup \dda(r_2) & \text{otherwise}
          \end{cases}
      \]
   \end{minipage}
   \begin{minipage}[t]{0.3\textwidth}
      \[\nr{6} \dda(r_1 \cap r_2) = \dda(r_1) \circledcap \dda(r_2)\]
   \end{minipage}

   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{7} \dda(r^n) =
          \begin{cases}
             \dda(r) & \text{if } n = 1 \\
             \dda((r, r^{n-1})) & \text{otherwise}
          \end{cases}
      \]
   \end{minipage}
   \begin{minipage}[t]{0.4\textwidth}
      \[\nr{8} \dda(\neg r) = \circledneg (\dda(r))\]
   \end{minipage}
\end{defn}

Caron et al. define \nr{1} as $\dda(b) = \emptyset$, but this yields incorrect
results when combined with negation. Consider for example the regular expression
$\neg b$, which matches anything that is not a `b', such as ``a''.  The partial
derivative over `a' according to \cite{pdere} would be constructed as follows:

\[\dda(\neg b)
   =_{\nr{8}} \circledneg \dda(b)
   =_{\nr{1}} \circledneg (\emptyset)
   = \emptyset
\]

The correct partial derivative is $\dda(\neg b) = \{\{\Sigma^*\}\}$. With our
definition, we construct the partial derivative as follows, considering that the
negation of the empty language is every possible word made from any number of
letters in the alphabet $\Sigma$:

\[\dda(\neg b)
   =_{\nr{8}} \circledneg \dda(b)
   =_{\nr{1}} \circledneg (\{\{\phi\}\})
   = \{\{\neg\phi\}\}
   = \{\{\Sigma^*\}\}
\]



% vim:tw=80
