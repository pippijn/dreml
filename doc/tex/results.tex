\chapter{Empirical results}
\label{results}


Performance of the tool was one of the main goals for this thesis, so an
evaluation is required. Not many regular expression matchers support the kind of
extended regular expressions we support, making a comparison with them
difficult. The only other tool that does is \mlulex{}, however doing so with
derivatives and not supporting submatching. All comparisons in the following
were done with \reml{} and \mlulex{}. Automata construction in Perl and PCRE are
several orders of magnitude faster than in both \reml{} and \mlulex{}, making a
comparison on this level inexpressive.

\section{Automata construction}

\subsection{Simple expression}

Here, the time taken to construct an automaton for $a^n$ is measured. The number
of states is $n + 1$ in both NFA (partial derivative) and DFA (derivative)
construction. \mlulex{} performs slighty better.

\img{img/con-an}{12cm}

\subsection{Worst-case regular expression}

DFA powerset construction takes exponential time and space when compiling the
expression $(a+b)^*b(a+b)^n$. Since \mlulex{} constructs a DFA, the time taken
during compilation is exponential in $n$. \reml{} uses partial derivatives to
construct an NFA and takes linear time.

\img{img/dfa-exp}{12cm}

\subsection{Worst-case extended regular expression}

Given the expressions $r_1 = (a+b)^*b(a+b)^n$, $r_2 = (\neg(\neg a + \neg
b))^*b(a+b)^n$ and $r = r_1 \cap r_2$, a natural partial derivative construction
would reduce to a full derivative computation. Here we can see that \reml{}, by
adopting the sets of sets extension, produces only a polynomial number of
states.

\img{img/dfa-states}{12cm}


\section{Automata simulation}

In order to measure the performance of each matching engine, this test creates a
string of length $n \cdot 1024$ with only the letter $a$ repeated, and matches
it with the regular expression $a^*$.

\img{img/astar}{12cm}

This test also considers Perl and PRCE, both of which are much faster on this
straightforward expression, but display exponential runtime behaviour for
expressions such as $(a?)^na^n$. The graph shows that \reml{} has competetive
matching performance with \mlulex{}, despite the overhead of keeping track of
multiple states. \reml{} uses tables and a simulation loop while \mlulex{}
generates efficient SML code with mutually recursive functions. \mlulex{} also
implements a table based lexer engine, which is about three to four times slower
than its code based engine.

Our results show that a solution based on partial derivatives can have
competetive performance with one based on derivatives and can vastly outperform
a derivative based automata construction in cases where the number of states
between NFA and DFA differ substantially.


% vim:tw=80
