\subsection{PCRE}

\begin{itemize}

   \item Support extended regular expressions in the form of both positive and
      negative look-ahead and look-behind assertions.

   \item Backtracking based approach.

\end{itemize}


The Perl Compatible Regular Expressions library is a C library that attempts to
bring the power of Perl regular expressions to other languages. PCRE and Perl
differ in a few instances, but their semantics and syntax are mostly equivalent.
In particular, Perl allows arbitrary Perl code to be executed within a match,
whereas PCRE does not include a Perl interpreter and can therefore never
implement this feature. However, PCRE does provide a way to call C code in named
``callout'' points.

\subsubsection{Automata construction}

PCRE is very fast at compiling a regular expression. The expression is compiled
to a byte-code program, which is optionally compiled to machine code.


\subsubsection{Matching performance}

The default matching algorithm used by the library is based on backtracking. The
regular expression is translated to a program that operates by processing one
path of an expression at a time, going back to the last matched text and program
position.

For example, consider the regular expression $(x_1:a^*)(x_2:a)(x_3:b^*)(x_4:b)$,
which matches any number of $a$ followed by any number of $b$, but at least one
of each. Matching the string $aabb$ against this pattern with a backtracking
algorithm will first attempt process the sub-expression $a^*$ by repeatedly
processing the sub-expression $a$ until it fails, so that $x_1 = aa$. Then, it
tries to match $(x_2:a)$, which fails, because the input is now at $b$, so the
algorithm backs up to the position at which the last successful match began, and
proceeds to process the input $abb$.

This algorithm requires the matcher to process the input up to $2^n$ times, as
there might be an exponential number of paths to test.

PCRE offers a DFA implementation as alternative matching algorithm, which is not
Perl compatible, but very efficient. Furthermore, it includes a Just-In-Time
compiler based on sljit, the stackless JIT compiler, increasing matching
performance by several times\footnote{\texttt{pcregrep --no-jit} was between two
and five times slower than without \texttt{--no-jit} for various patterns.}.

A pattern that causes particularly bad performance in PCRE is $(a?)^na^*b$. For
this expression, PCRE takes exponential time, and a DFA takes linear time.


\subsubsection{Accepted syntax}

PCRE supports the richest syntax of all investigated regular expression
implementations. It aims to support the full syntax as specified by the Perl
regular expression man page \texttt{perlre}. For obvious reasons, inline Perl
code is not supported by PCRE, but the syntax allows for extension points, which
can call arbitrary C functions after a sub-expression has been matched.

Negation is supported in various ways, through negative zero-width look-ahead
assertions written \verb'(?!pattern)', where \verb'foo(?!bar)' matches "foo", if
it is not followed by a "bar". PCRE look-ahead assertions are zero-width, so
they do not consume any input, unlike the negation in our extended regular
expressions. However, negative look-ahead can achieve the same effect, so that
our introductory example pattern matching C comments can be written as
\verb'/\*((?!\*/).)*\*/' in PCRE.

However, this expression will fail to match long comments, causing a stack
overflow in the engine. In PCRE version 8.31 on AMD64 Linux with an 8MiB stack,
the engine fails to match comments longer than 6KiB. Disabling the capture group
makes it slightly better, so that the expression \verb'/\*(?:(?!\*/).)*\*/'
fails at 11KiB comments. Since comments are often used to disable large code
blocks, such behaviour is unacceptable, and one is forced to write the more
convoluted term \verb'/\*(([^*]|\*[^/])*)\*/'. The expression with negation does
require linear time in PCRE, but also uses linear stack space, quickly running
out. An automata based approach will achieve linear time and constant space for
this expression.


% vim:tw=80
