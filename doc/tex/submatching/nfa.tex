\section{The submatch automaton}
\label{nfa}

Given the definition of the partial derivative of a submatching pattern $\dda$,
which yields a set of expression sets, we can define a function yielding the
partial derivative for a pattern $p$:
$\cdot \setminus_p \cdot :: p \to l \to \{(p, x \to l)\}$

$p \setminus_p l = \{ (\mathcal{P}\downarrow, f) | (\mathcal{P}, f) \in \dd{l}(p) \}$

Using this function, the submatching automaton can be constructed by iteratively
constructing the partial derivative of the input pattern over each letter in the
alphabet. The resulting set of derivated terms is then filtered to remove all
those that describe the empty language. This filtered set is then used as input
and each term is derived over each letter again. This is done until no new terms
appear or all terms yield the empty language, i.e. $L(p) = \emptyset$.

\begin{eg}
   Given the alphabet $\Sigma = \{a, b, c\}$ and the pattern expression $p =
   (x:a, p_2)$ where $p_2 = (y:\neg c, p_3)$ and $p_3 = (z:ab + ac)$, we can
   construct the automaton as follows:

   \begin{tabular}{lll}
      $\dda(a)$
      & $=_{\nr{2}}$ &
         $\{\{ \varepsilon \}\}$
   \end{tabular}

   \needspace{5cm}
   \begin{tabular}{lll}
      $\dda(((x:a), p_2))$
      & $=_{\nr{5p}}$ &
         $\dda(x:a) \circledcdot_{\id} p_2$
      \\ & $=_{\nr{1p}}$ &
         $\{ (\{ \eset\reOfEset \}, \updatexa) | \eset \in \dda(a) \}
            \circledcdot_{\id} p_2$
      \\ & $=$ &
         $\{ (\{ \varepsilon \}, \updatexa) \}
            \circledcdot_{\id} p_2$
      \\ \multicolumn{3}{l}
         {By definition \ref{defn-pset-ops}, and we cancel the identity function
         in the update chain.}
      \\ & $=$ &
         $\{ (\{ (\varepsilon, p_2) \}, \updatexa) \}$
      \\ \multicolumn{3}{l}
         {Simplification $(\varepsilon, p) = p$:}
      \\ & $=$ &
         $\{ (\{ p_2 \}, \updatexa) \}$
   \end{tabular}

   The resulting set of pattern sets contains the partial derivative over the
   letter $a$. The partial derivative over $b$ and $c$ will yield the empty
   language $\{ (\{ (\phi, p_2) \}, \updatexa) \}$. These are filtered out at
   the end of the iteration. The remaining sets are converted to partial
   derivatives according to the $\cdot \setminus_p \cdot$ operator, resulting in
   $p \setminus_p a = \{ (p_2, \updatexa) \}$. In the next iteration, we
   continue with the set of derivated terms from the previous iteration, in this
   case just $p_2$.

   \begin{tabular}{lll}
      $\dda(\neg c)$
      & $=_{\nr{8}}$ &
         $\circledneg (\dda(c))$
      \\ & $=_{\nr{1}}$ &
         $\circledneg (\{\{\phi\}\})$
      \\ \multicolumn{3}{l}
         {By definition \ref{defn-eset-ops}:}
      \\ & $=$ &
         $\{\{\neg\phi\}\}$
   \end{tabular}

   \begin{tabular}{lll}
      $\dda(((y:\neg c), p_3))$
      & $=_{\nr{5p}}$ &
         $\dda(y:\neg c) \circledcdot_{\id} p_3 \cup \dda(p_3)$
      \\ & $=_{\nr{1p}}$ &
         $\{ (\{ \eset\reOfEset \}, \update{y}{a}) | \eset \in \dda(\neg c) \}
            \circledcdot_{\id} p_3 \cup \dda(p_3)$
      \\ & $=$ &
         $\{ (\{ \neg\phi \}, \update{y}{a}) \}
            \circledcdot_{\id} p_3 \cup \dda(p_3)$
      \\ & $=$ &
         $\{ (\{ (\neg\phi, p_3) \}, \update{y}{a}) \} \cup \dda(p_3)$
   \end{tabular}

   Since $\varepsilon \in L(\neg c)$, we also need to compute $\dda(p_3)$ and
   unite the resulting set of pattern sets with $\dda(y:\neg c)$.

   \begin{tabular}{lll}
      $\dda(ab + ac)$
      & $=_{\nr{3}}$ &
         $\dda(ab) \cup \dda(ac)$
      \\ & $=_{\nr{5}}$ &
         $\dda(a) \circledcdot b \cup \dda(a) \circledcdot c$
      \\ & $=_{\nr{2}}$ &
         $\{\{\varepsilon\}\} \circledcdot b \cup \{\{\varepsilon\}\} \circledcdot c$
      \\ & $=$ &
         $\{\{\varepsilon b\}\} \cup \{\{\varepsilon c\}\}$
      \\ & $=$ &
         $\{\{\varepsilon b\}, \{\varepsilon c\}\}$
   \end{tabular}

   \begin{tabular}{lll}
      $\dda(z:ab + ac)$
      & $=_{\nr{1p}}$ &
         $\{ (\{ \eset\reOfEset \}, \update{z}{a}) | \eset \in \dda(ab + ac) \}$
      \\ & $=$ &
         $\{ (\{ \eset\reOfEset \}, \update{z}{a}) | \eset \in \{\{\varepsilon b\}, \{\varepsilon c\}\} \}$
      \\ & $=$ &
         $\{ (\{ \varepsilon b \}, \update{z}{a}), (\{ \varepsilon c \}, \update{z}{a}) \}$
      \\ \multicolumn{3}{l}
         {Simplification $(\varepsilon, p) = p$:}
      \\ & $=$ &
         $\{ (\{ b \}, \update{z}{a}), (\{ c \}, \update{z}{a}) \}$
   \end{tabular}

   The resulting set of pattern sets is
   \[\dda(\neg c) \cup \dda(z:ab + ac) = \{ (\{ (\neg\phi, p_3) \},
   \update{y}{a}), (\{ b \}, \update{z}{a}), (\{ c \}, \update{z}{a}) \}\].

   After using the same method to iteratively construct the entire automaton,
   the states and transitions will be as in the following graph:

   \img{img/nfa}{16cm}

\end{eg}


% vim:tw=80
