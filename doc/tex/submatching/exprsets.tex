\section{Partial derivatives}
\label{exprsets}

The syntax of patterns and regular expressions, as well as the formal
specification of the pattern matching relation can now be used to define the
pattern partial derivative function.

\subsubsection{Sets of pattern sets}

The partial derivative operations are defined on extended regular expressions
and result in sets of expression sets. Pattern partial derivatives as defined in
\cite{pdpat} result in a list of pairs containing the derivated term as well as
a transition function $x \mapsto l$ recording the fact that the letter $l$ has
been consumed by a pattern under a variable $x$. This function must be recorded
in the set of pattern sets, as well. Since the equivalent of a derivated term is
the expression set $\eset$, we define the set of pattern sets as: $\{ (\{ p \},
x \to l) \}$, the set of pairs containing an expression set and the associated
transition function. Sets of pattern sets are defined similarly to sets of
expression sets in definition \ref{defn-esets}.

\begin{defn}
   \label{defn-psets}
   Syntax for sets of pattern sets.

   \begin{tabular}{lll}
      $\pset$	& $::=$ & $(\{r_1, r_2, \dots, r_n\}, x \to l)$ \\
      $\psets$	& $::=$ & $\{\pset_1, \pset_2, \dots, \pset_n\}$ \\
   \end{tabular}
\end{defn}

Similarly to the additional requirement for Sulzmann and Lu's pattern partial
derivatives, our sets of pattern sets are in fact ordered sets, ordered by their
origin. That means the pattern $(x:ac)(y:ab)$ represented as set of pattern sets
is $\{\{x:ac\}, \{y:ab\}\}$, exactly in that order. This post-condition is
required to ensure that matching strategies such as the greedy left-most and
POSIX match operate correctly.


\subsubsection{Conversions}

We can define translations from the above extended regular expression syntax to
the sets of sets representation. Let $\esets$ be a set of expression sets,
$\eset$ an expression set, and $r$ an expression, then we can define the
following operators:

\begin{defn}
   \label{defn-re2esets}
   Conversions from regular expressions to expression sets.

   Expression set from regular expression:
   $\cdot\esetOfRe :: r \to \eset$

   \begin{tabular}{lll}
      $(r_1 \cap r_2)\esetOfRe$	& $=$	& $r_1\esetOfRe \cup r_2\esetOfRe$	\\
      $r\esetOfRe$			& $=$	& $\{r\}$			\\
   \end{tabular}

   Set of expression sets from regular expression:
   $\cdot\esetsOfRe :: r \to \esets$

   \begin{tabular}{lll}
      $(r_1 + r_2)\esetsOfRe$	& $=$	& $r_1\esetsOfRe \cup r_2\esetsOfRe$	\\
      $r\esetsOfRe$		& $=$	& $\{r\esetOfRe\}$			\\
   \end{tabular}
\end{defn}

The following example shows how a regular expression is transformed into the DNF
representation of atomic expressions.

\begin{eg}
   $((aa \cap a^*) + b)\esetsOfRe$

   \begin{tabular}{lll}
      $((aa \cap a^*) + b)\esetsOfRe$
      & $=$	& $((aa \cap a^*)\esetsOfRe) \cup (b\esetsOfRe)$		\\
      & $=$	& $\{(aa \cap a^*)\esetOfRe\} \cup \{b\esetsOfRe\}$		\\
      & $=$	& $\{(aa)\esetOfRe \cup (a^*)\esetOfRe\} \cup \{\{b\}\}$	\\
      & $=$	& $\{\{aa\} \cup \{a^*\}\} \cup \{\{b\}\}$			\\
      & $=$	& $\{\{aa, a^*\}, \{b\}\}$					\\
   \end{tabular}
\end{eg}

If the operator at the highest level of the syntax tree is not the choice
operator $+$, the resulting set will contain exactly one expression set. If the
expression contains no intersections, the expression set will contain exactly
one atomic expression. A negation at the highest level is an example of such a
case: $\neg((aa \cap a^*) + b)\esetsOfRe = \{\{\neg((aa \cap a^*) + b)\}\}$

The inverse operation, translating a set of expression sets back to a regular
expression, can be defined analogously.

\begin{defn}
   \label{defn-esets2re}
   Conversions from expression sets back to regular expressions.

   Regular expression from expression set: $\cdot\reOfEset :: \eset \to r$

   \begin{tabular}{lll}
      $\{r\}\reOfEset$			& $=$	& $r$				\\
      $(\{r\} \cup \eset)\reOfEset$	& $=$	& $r \cap \eset\reOfEset$	\\
   \end{tabular}

   Regular expression from a set of expression sets: $\cdot\reOfEsets :: \esets \to r$

   \begin{tabular}{lll}
      $\{\eset\}\reOfEsets$		& $=$	& $\eset\reOfEset$		\\
      $(\{\eset\} \cup \esets)\reOfEsets$	& $=$	& $r + \esets\reOfEsets$	\\
   \end{tabular}
\end{defn}

The operation is not defined on empty sets, thus the set of expression sets
representing the empty language expression must be the set containing the set
with the empty language symbol: $\{\{\phi\}\}$.

The operators $\esetOfRe$ and $\reOfEset$ can be defined analogously for
patterns to construct pattern sets and reconstruct the pattern from them.

\begin{defn}
   \label{defn-re2pset}
   Conversions from patterns to pattern sets.

   Pattern set from expression pattern:
   $\cdot\esetOfRe :: p \to \pset$

   \begin{tabular}{lll}
      $(p_1 \cap p_2)\esetOfRe$	& $=$	& $p_1\esetOfRe \cup p_2\esetOfRe$	\\
      $p\esetOfRe$			& $=$	& $\{p\}$			\\
   \end{tabular}
\end{defn}

It should be noted that in order to break a pattern or expression into a set of
pattern or expression sets, the highest level operator must be choice or
intersection. In particular, a pattern group $(x:p)$ at the highest level of the
syntax tree makes it impossible to break a pattern into pieces.

For a pattern group containing a choice operator, it would be possible to split
it into multiple pattern groups with the same variable name, each containing one
choice. However, this would break the invariant that every variable name exists
exactly once in the pattern, so splitting would require variable renaming and
tracking.

The inverse operator is defined analogously to definition \ref{defn-re2esets}.

\begin{defn}
   \label{defn-re2psets}
   Conversions from pattern sets back to patterns.

   Pattern from pattern set:
   $\cdot\reOfEset :: \pset \to r$

   \begin{tabular}{lll}
      $\{p\}\reOfEset$			& $=$	& $p$				\\
      $(\{p\} \cup \pset)\reOfEset$	& $=$	& $p \cap \pset\reOfEset$	\\
   \end{tabular}
\end{defn}

We do not define $\esetsOfRe$ and $\reOfEsets$ for sets of pattern sets, and
there is no need for them, but the final pattern derivative as set of patterns
with transition functions can be obtained from a pattern using the function
$\cdot \setminus_p \cdot$ detailed and illustrated in section \ref{nfa}.


\subsubsection{Operators on sets of pattern sets}

The expression set operators from definition \ref{defn-eset-ops} must be defined
for pattern derivatives, but since pattern derivatives carry a transition
function $f$, these must be sensibly combined in the set operators.

\begin{defn}
   \label{defn-pset-ops}
   Distributive laws on sets of pattern sets.

   \begin{tabular}{lll}
      $\psets \circledcdot_{mod} p_2$
         & $=$
         & $\{ (\{ (p_1, p_2) | p_1 \in \eset \}, f \circ mod) | (\eset, f) \in \psets \}$
         \\

      $\psets_1 \circledcap \psets_2$
         & $=$
         & $\{
              (\eset_1 \cup \eset_2, f_1 \circ f_2)
              | (\eset_1, f_1) \in \psets_1, (\eset_2, f_2) \in \psets_2
           \}$
         \\
   \end{tabular}
\end{defn}

In $\circledcdot$, the $mod$ function can modify the environment before passing
it to the transition function.  The operator $\circledneg$ is not defined for
sets of pattern sets, since there is no negation for patterns.


\subsection{Pattern partial derivatives}

We define the partial derivative of an extended pattern expression using the
operators $\circledcdot$ and $\circledcap$, omitting negation. This definition
is an extension of definition \ref{defn-pd-eset} with the semantics from the
pattern matching relation in definition \ref{patmatchrel}.

\begin{defn}
   \label{defn-pd-pset}
   Pattern partial derivatives as sets of pattern sets.

   \[\nr{1p}\quad \dda(x:r)
      = \{ (\{ \eset\reOfEset \}, \updatexa) | \eset \in \dda(r) \}\]
   \[\nr{2p}\quad \dda(x:p)
      = \{ (\{ (x:\pset\reOfEset) \}, \updatexa \circ f) | (\pset, f) \in \dda(p) \}\]
   \[\nr{3p}\quad \dda(p_1 + p_2) = \dda(p_1) \cup \dda(p_2)\]
   \[\nr{4p}\quad \dda(p^*) = \dda(p) \circledcdot_{\iterate} p^*\]
   \[\nr{5p}\quad \dda((p_1, p_2)) =
       \begin{cases}
          \dda(r_1) \circledcdot_{id} p_2 & \text{if } \varepsilon \not\in L(p_1\reOfEsets) \\
          \dda(r_1) \circledcdot_{id} p_2 \cup \dda(p_2) & \text{otherwise}
       \end{cases}
   \]
   \[\nr{6p}\quad \dda(p_1 \cap p_2) = \dda(p_1) \circledcap \dda(p_2)\]
   \[\nr{7p}\quad \dda(p^n) =
       \begin{cases}
          \{ (\pset, f \circ \iterate) | (\pset, f) \in \dda(p) \} & \text{if } n = 1 \\
          \dda(p) \circledcdot_{\iterate} p^{n-1} & \text{otherwise}
       \end{cases}
   \]
\end{defn}

In \nr{5p}, the identity function is given as modifier to the $\circledcdot$
operator, keeping the environment as is before passing it to the transition
function. The $\iterate$ function can modify the environment for the two
iterating patterns $p^*$ and $p^n$. It can choose to keep only the last match or
all matches, by renaming past recorded match variables. This function is
described in more detail in section 5.1 of \cite{pdpat}. The $\fv(p)$ function
finds all free variables used in the pattern, and is defined in section 3.1 of
the same paper.


% vim:tw=80
